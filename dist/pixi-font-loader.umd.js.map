{"version":3,"file":"pixi-font-loader.umd.js","sources":["../src/cssTools.ts","../src/WebfontLoaderPlugin.ts"],"sourcesContent":["function parseRule(css: string): any\n{\n    const tokenizer = /\\s*([a-z\\-]+)\\s*:\\s*((?:[^;]*url\\(.*?\\)[^;]*|[^;]*)*)\\s*(?:;|$)/gi;\n    const obj: any = {};\n    let token;\n\n    while ((token = tokenizer.exec(css)))\n    {\n        obj[token[1].toLowerCase()] = token[2];\n    }\n\n    return obj;\n}\n\nfunction stringifyRule(style: any): string\n{\n    let text = '';\n    const keys = Object.keys(style).sort();\n\n    for (let i = 0; i < keys.length; i++)\n    {\n        text += ` ${keys[i]}: ${style[keys[i]] as string};`;\n    }\n\n    return text.substring(1);\n}\n\n/**\tParse a CSS StyleSheet into an Array of CSSStyleRule objects,\n\t *\teach having normalized `selectorText` and `style` properties.\n\t *\tHardcore regex stolen from: https://jsfiddle.net/developit/vzkckrw4/\n\t *\t@param {String} stylesheet\n\t *\t@returns {Array(CSSStyleRule)}\n\t */\nexport function parseCss(text: string): { selectorText: string; style: any; cssText: string }[]\n{\n    const tokenizer = /([\\s\\S]+?)\\{([\\s\\S]*?)\\}/gi;\n    const rules = [];\n    let rule;\n    let token;\n\n    text = text.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n    while ((token = tokenizer.exec(text)))\n    {\n        const style = parseRule(token[2].trim());\n\n        style.cssText = stringifyRule(style);\n        rule = {\n            selectorText: token[1].trim().replace(/\\s*\\,\\s*/, ', '),\n            style,\n            cssText: '',\n        };\n        rule.cssText = `${rule.selectorText} { ${rule.style.cssText as string} }`;\n        rules.push(rule);\n    }\n\n    return rules;\n}\n","import { LoaderResource, ILoaderPlugin } from '@pixi/loaders';\nimport { parseCss } from './cssTools';\n\nexport default class WebfontLoaderPlugin implements ILoaderPlugin\n{\n    /**\n     * Unsuported formats:\n     * EOT => Internet explorer only. Deprecated. We use promises, we don't support IE anyway.\n     * SVG => Safari only. Deprecated. Spec removed from SVG 2.0. Support being removed from browsers.\n     */\n    private static readonly supportedFontExtensions = ['ttf', 'otf', 'woff', 'woff2'];\n\n    static add(..._params: any[]): any\n    {\n        if (!document.fonts || !FontFace || !Promise)\n        {\n            throw new Error(\n                'WebfontLoaderPlugin relies heavily on Promises and the FontFace API and your browser doesn\\'t support them.'\n            );\n        }\n\n        LoaderResource.setExtensionLoadType('css', LoaderResource.LOAD_TYPE.XHR);\n        LoaderResource.setExtensionXhrType('css', LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n\n        LoaderResource.setExtensionLoadType('ttf', LoaderResource.LOAD_TYPE.XHR);\n        LoaderResource.setExtensionXhrType('ttf', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n\n        for (const ext of WebfontLoaderPlugin.supportedFontExtensions)\n        {\n            LoaderResource.setExtensionLoadType(ext, LoaderResource.LOAD_TYPE.XHR);\n            LoaderResource.setExtensionXhrType(ext, LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n        }\n    }\n\n    static use(resource: LoaderResource, next: (...params: any[]) => any): void\n    {\n        if (resource.extension.endsWith('css'))\n        {\n            // this promise _shouldnt_ reject but just to be sure, finally;\n            WebfontLoaderPlugin.loadFromCSS(resource).finally(() => next());\n\n            return;\n        }\n\n        if (WebfontLoaderPlugin.supportedFontExtensions.some((ext) => resource.extension.endsWith(ext)))\n        {\n            // this promise _shouldnt_ reject but just to be sure, finally;\n            WebfontLoaderPlugin.loadFromBuffer(resource).finally(() => next());\n\n            return;\n        }\n\n        // fallback, it wasn't for us\n        next();\n    }\n\n    /**\n     * Overwriteable function in case you want to implement your own waiter\n     * (e.g: FontFaceObserver)\n     */\n    public static waitFont = async (\n        fontDescriptor:{'font-family':string, 'font-style'?:string, 'font-weight'?:string, 'font-stretch'?:string},\n        testString:string,\n        timeout:number): Promise<void> =>\n    {\n        const fontStyle = fontDescriptor['font-style'] ?? '';\n        const fontWeight = fontDescriptor['font-weight'] ?? '';\n        const fontStretch = fontDescriptor['font-stretch'] ?? '';\n        const fontFamily = fontDescriptor['font-family'];\n\n        timeout = timeout || Infinity; // timeout=0 -> wait forever\n        let now = new Date().getTime();\n        const backThen = now;\n        const mergedFontStyle:string = [fontStyle, fontWeight, fontStretch, '100px', fontFamily].join(' ');\n        let loadedFonts = 0;\n\n        do\n        {\n            loadedFonts = (await document.fonts.load(mergedFontStyle, testString)).length;\n            if (loadedFonts > 0)\n            {\n                // Font loaded!\n                return;\n            }\n\n            // sleep for a while or the browser can't load the fonts!\n            await new Promise((resolve) => setTimeout(resolve, 16));\n\n            now = new Date().getTime();\n        } while (now - backThen < timeout);\n\n        // We timed out! :(\n        console.warn(`Error loading font! Your font ${fontDescriptor['font-family']} timed out after ${timeout}ms`);\n    };\n\n    private static loadFromCSS(resource: LoaderResource) : Promise<any>\n    {\n        const newLink = document.createElement('link');\n\n        newLink.rel = 'stylesheet';\n        newLink.type = 'text/css';\n        newLink.href = resource.url;\n\n        // append to head\n        document.head.appendChild(newLink);\n\n        // parse the css\n        const allFonts = parseCss(resource.data);\n\n        // make the outputs\n        const promiseArr = [];\n        const fontDefinitionArr = [];\n\n        const testString = resource.metadata?.font?.testString;\n        const timeout = resource.metadata?.font?.timeout ?? resource.timeout;\n\n        for (const font of allFonts)\n        {\n            if (typeof font.style['font-family'] === 'string')\n            {\n                // add watchface promises\n                promiseArr.push(\n                    WebfontLoaderPlugin.waitFont(font.style, testString, timeout)\n                );\n\n                // make the loaded font data for later user reference\n                fontDefinitionArr.push({\n                    fontFamily: font.style['font-family'].replace(/['|\"]/gi, ''),\n                    fontStyle: font.style['font-style'],\n                    fontWeight: font.style['font-weight'],\n                    // fontStretch: font.style[\"font-stretch\"], //pixi doesn't know this\n                });\n            }\n        }\n\n        // store the fonts that we loaded\n        resource.styles = fontDefinitionArr;\n\n        // wait for all fonts to be ready\n        // use finally because loaders in pixi ALWAYS end. Even on catastrophic failures.\n        return Promise.all(promiseArr);\n    }\n\n    private static loadFromBuffer(resource:LoaderResource) : Promise<void>\n    {\n        // If you don't specify a family name the resource name is used\n        const fontFamily = resource.metadata?.font?.family ?? resource.name;\n\n        // Add it to the document\n        document.fonts.add(new FontFace(fontFamily, resource.data, resource.metadata?.font));\n\n        // Add the style descriptor (I don't think nobody ever used this...)\n        resource.styles = [{\n            fontFamily: fontFamily.replace(/['|\"]/gi, ''),\n            fontStyle: resource.metadata?.font?.style,\n            fontWeight: resource.metadata?.font?.weight,\n            // fontStretch: font.style[\"font-stretch\"], //pixi doesn't know this\n        }];\n\n        // Usually this resolves instantly because we had the buffer in resource.data\n        return WebfontLoaderPlugin.waitFont(\n            {\n                'font-family': fontFamily,\n                'font-stretch': resource.metadata?.font?.stretch,\n                'font-style': resource.metadata?.font?.style,\n                'font-weight': resource.metadata?.font?.weight\n            },\n            resource.metadata?.font?.testString, resource.metadata?.font?.timeout ?? resource.timeout);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;CAAA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;;CAEA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;;wmBCtDA;;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;;;;;;;;;;"}